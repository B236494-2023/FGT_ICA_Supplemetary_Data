---
output:
  pdf_document: default
  html_document: default
---

    title: "Affymetrix Microarray Minimal pipeline"
    author: "B236494 20/04/2024"
    output: html_document

```{r setup + libload, include=FALSE}
# This is the setup code chunk that is only executed once to load the neccessary libraries

knitr::opts_chunk$set(echo = TRUE)

library(limma)
library(affy)
library(annotate)
library(mouse4302.db)# load chip-specific annotation
library(ggplot2)
library(knitr)
library(tinytex)

#install.packages("scatterplot3d",repo="http://cran.ma.imperia#l.ac.uk")
#Then load the library
library(scatterplot3d)
```

# B236494 - Affymetrix Microarray Analysis Basic Workflow

This code has been adapted from the BasicAnalysisScript.Rmd file provided by Simon Tomlinson. This code has been altered to account for author specific input files and samples while retaining the main features of the pipeline. The R Script can be generated for this document by running the last chunk which has been turned off by default Interpretations of the results have been provided alongside the results for convenient viewing. Comments have been added to aid in understanding the flow of execution Please ensure that the right .CEL are located in the working directory for the Code to work. This can be downloaded from the GEO website using the supplementary code provided at the end of the report.

Note: An additional analysis tool was identified known as GEO2R, the analysis of an entry in GEO can also be done using this. It is available at [https://www.ncbi.nlm.nih.gov/geo/geo2r/](https://www.ncbi.nlm.nih.gov/geo/geo2r/?acc=GSE137166)

# Pipeline Steps:

## Loading Data & Introduction

Using the read.AnnotatedDataFrame() the targets are loaded from "B236494_edited_final_targets_file.txt" file into an object. The parameters ensure that the header is accounted for. Following this, the ReadAffy() is used to load information from the .CEL files that were previously extracted from the .tar file that was obtained from Gene Expression Omnibus (GEO).

The samples are from the study, "Endometrial epithelial ARID1A is critical for uterine gland function in early pregnancy establishment" by Marquardt *et al.,* with GEO accession number GSE137166. It was an expression profiling by array experiment type.

AT-rich interaction domain 1A (ARID1A) is a large protein switch/sucrose non-fermentable (SWI/SNF) chromatin remodeling complex subunit which acts as a tumor suppressor.

The *Arid1a* gene was known to have a vital function in regulating the development of the endometrial gland which is essential for fertility after maturity and normal uterine function. Marquardt *et al.* presented evidence of how ARID1A binds and the proceeds to modulate transcription of the *Foxa2* gene that is essential for endometrial gland functioning. They also showed that deletion of *Arid1a* in a uterine specific context results in a severe defect to gland development and consequentially diminished *Foxa2* and *Lif* expression.

There were two types of mice that were used to study this gene. Arid1a d/d and Arid1a f/f mice. In Arid1a f/f the *Arid1a* has been retained while it has been deleted in the Arid1a d/d mice. At 2 weeks of growth, uteri of 3 of each type of mice was selected for RNA extraction and hybridization of Affymetrix microarrays.

The sample names are as follows:

-   GSM4072331	Arid1a f/f 1
-   GSM4072332	Arid1a f/f 2
-   GSM4072333	Arid1a f/f 3
-   GSM4072334	Arid1a d/d 1
-   GSM4072335	Arid1a d/d 2
-   GSM4072336	Arid1a d/d 3

The goals of this analysis pipeline involves a few key steps:

-    To assess the quality of the data
-   Perform Normalisation of the data
-   Robust Multi-array Average (RMA)
-   Functional Enrichment Analysis
-   Selection of Differentially Expressed Genes

The Affy and Limma Bioconductor packages will be main tools that will be used throughout this pipeline with descriptions of the code as the execution proceeds.



```{r dataload, echo=TRUE}

# Load the target file into an AnnotatedDataFrame object
adf<-read.AnnotatedDataFrame("B236494_edited_final_targets_file.txt",header=TRUE,row.names=1,as.is=TRUE)
# Load the expression values of all the CEL files in the targets file
mydata <- ReadAffy(filenames=pData(adf)$FileName,phenoData=adf)

# Or just to quickly load all CEL files in the R working directory
mydata <- ReadAffy()
# View a summary of the example data
mydata
```

## Build Quality Control Plots

```{r qc_plots1, echo=TRUE}

# Quality control plots
hist(mydata)

# And a boxplot with different colour per sample group
colours <- c(rep("yellow",3),rep("red",3))

boxplot(mydata, col=colours, las=2)

```

## Normalise the data using RMA

```{r normalise, echo=FALSE}

eset <- rma(mydata)
eset
# To obtain a matrix of the expression values, use exprs() 
values <- exprs(eset)

```

## Plot Normalised Data

```{r plot_normalised boxplot, echo=FALSE}
# Boxplot to observe the results of normalisation
# Notice differences with the boxplot from the raw data
boxplot(values, col=colours,las=2)
```

```{r plot_normalised mva without normalisation}
# The mva plot for the non-normalised raw data
mva.pairs(pm(mydata))
```

```{r plot_normalised mva with normalisation}
# MA plot of the samples 1 and 4
mva.pairs(values)

```

## Plot Heatmap

```{r heatmap_normalised, echo=FALSE}

# To facilitate interpretation, let’s replace the columns # # header,currently
# displaying the filename, to show the name of each sample 
# (if you have a targets file)
colnames(values) <- rownames(pData(adf))
# Performs hierarchical clustering with average linkage based on
# Pearson’s Correlation Coefficient
hc<-hclust(as.dist(1-cor(values, method="pearson")), method="average")
plot(hc)
```

## Perform PCA

```{r pca_normalised, echo=FALSE}

### removed scale=T, i think its already normalised
pca <- prcomp(t(values))
# Plot the PCA results

s3d<-scatterplot3d(pca$x[,1:3], pch=19, color=rainbow(1))
s3d.coords <- s3d$xyz.convert(pca$x[,1:3])
text(s3d.coords$x, s3d.coords$y, labels = colnames(values),pos = 3,offset = 0.5)
```

## Perform fold filtering

```{r fold_filtering, echo=TRUE}

#obtaining a matrix of expression values
exprsvals <- exprs(eset)
#RMA outputs log2 data while MAS5 outputs linear data
#To convert from log…
exprsvals10 <-2^exprsvals
#check conversion
exprsvals[1:10,]
#converted
exprsvals10[1:10,]

#More fold filtering
#check order of sample names
mysamples <- sampleNames(eset)
#display the list
mysamples
#it is useful to obtain a vector of ProbeIDs here
probesets <- probeNames(mydata)
#display the first 10 ProbeSets
probesets[1:10]

#Build final fold table
#Calculate the means
#Note mean of the log is not the same as the log of the mean!!
Arid1a_f_f.mean <- apply(exprsvals10[,c("GSM4072331_AF1_Mouse430_2_.CEL", "GSM4072332_AF2_Mouse430_2_.CEL","GSM4072333_AF3_Mouse430_2_.CEL")],1,mean)

Arid1a_d_d.mean <- apply(exprsvals10[,c("GSM4072334_AD1_Mouse430_2_.CEL", "GSM4072335_AD2_Mouse430_2_.CEL","GSM4072336_AD3_Mouse430_2_.CEL")],1,mean)
#calculate some fold changes
Arid1a_fold_change <- Arid1a_f_f.mean/Arid1a_d_d.mean
##ES_iPS_OK <-ES.mean /iPS_OK.mean
##ES_iPS_4F <-ES.mean /iPS_4F.mean
##ES_NSC <-ES.mean /NSC.mean

#build a summary table to hold all the data

##all.data= cbind(ES.mean,iPS_OK.mean,iPS_4F.mean, NSC.mean, ES_iPS_OK,ES_iPS_4F, ES_NSC)
all.data= cbind(Arid1a_fold_change)
#check the column names
colnames(all.data)
#write the table of means as an output
write.table(all.data,file="B236494_group_means.txt", quote=F,
sep="\t",col.names=NA)
```

## Beginning statistical analysis

```{r limma_stats, echo=TRUE}

#Check original sample order
sampleNames(eset)
#Rename the samples
sampleNames(eset) <-
c("GSM4072331_AF1_Mouse430_2_.CEL","GSM4072332_AF2_Mouse430_2_.CEL","GSM4072333_AF3_Mouse430_2_.CEL","GSM4072334_AD1_Mouse430_2_.CEL","GSM4072335_AD2_Mouse430_2_.CEL","GSM4072336_AD3_Mouse430_2_.CEL")
#Check the samples have renamed
sampleNames(eset)

```

```{r building_annotation, echo=TRUE}
##Building annotation for differential gene identification
#establish annotation for MOE430v2
#which annotation do we need
#modified from #http://gettinggeneticsdone.blogspot.co.uk/2012/01/annotating-limma-#results-with-gene.html

eset@annotation


#packages in the annotation package
ls("package:mouse4302.db")

#build an annotation table
ID <- featureNames(eset)
Symbol <- getSYMBOL(ID, "mouse4302.db")
Name <- as.character(lookUp(ID, "mouse4302.db", "GENENAME"))
tmp <- data.frame(ID=ID, Symbol=Symbol, Name=Name, stringsAsFactors=F)
tmp[tmp=="NA"] <- NA #fix padding with NA characters 
#assign as feature data of the current Eset
fData(eset) <- tmp

# Check for rows that don’t have an EntrezID
missing_entrezid_count <- sum(is.na(fData(eset)$ENTREZID))

print(missing_entrezid_count)

```

## Statistical analysis using Limma

```{r limma_statistical_analysis, echo=TRUE}

#Build the design matrix
design <- model.matrix(~-1+factor(c(1,1,1,2,2,2)))
colnames(design) <- c("Arid1a_f_f","Arid1a_d_d")
#Check it makes sense
sampleNames(eset)
#output the design matrix
design

#This instructs Limma which comparisons to make
contrastmatrix <- makeContrasts(Arid1a_f_f-Arid1a_d_d,levels=design)
contrastmatrix

#issue these commands to fit the model
#and make the contrasts
fit <- lmFit(eset, design)

fit2 <- contrasts.fit(fit, contrastmatrix)

#this last part essentially moderates the t-statistic using 
#the borrowed variance approach described in class
fit2 <- eBayes(fit2)

#get the results
topTable(fit2,coef=1,adjust="fdr")
myresults <-topTable(fit2,coef=1, adjust="fdr", number=nrow(eset))
write.table(myresults,"B236494_myresults.txt")
```

## Carry out Functional Enrichment analysis

```{r functional_enrichment, echo=TRUE}

Mm.H <- readRDS("/shared_files/MSigDB/Mm.h.all.v7.1.entrez.rds") 

#Check that you have the required objects
ls()

#Show the full contents of the annotation package
ls("package:mouse4302.db")

#Show the annotation keys in this database
keytypes(mouse4302.db) 

sampleNames(eset)
```

## Process annotation for functional enrichment

```{r process_annotation_for_enrichment, echo=TRUE}

#Here we select from the annotation a number of keys with the primary key being PROBEID
res <- select(mouse4302.db, keys = rownames(eset), columns = c("ENTREZID", "ENSEMBL","SYMBOL"), keytype="PROBEID")
#View the top of the table
head(res)
#find the index of each row of the expression set in the #annotation object res
idx <- match(rownames(eset), res$PROBEID)
#Use the index to set the phenotypic data in the ExpressionSet
fData(eset) <- res[idx, ]
head(fData(eset), 10)
#Find all rows that don’t have an EntrezID and remove then
eset_t<-eset[is.na(fData(eset)$ENTREZID)==0,]
```

## Functional Enrichment Analysis

```{r convert_indicex, echo=TRUE}

#convert to indexes
H.indices <- ids2indices(Mm.H,fData(eset_t)$ENTREZID)
#Pick the most suitable enrichment analysis tool to find #enrichment signatures in the data and run this tool So:-

#I just run mroast here as an example- justify the selection of this method!

#if you want to run mroast
#results_mroast <-mroast(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#if you want to run camera
results_camera <-camera(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#if you want to run romer
#results_romer <-romer(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#View the results
results_camera

#Use help for other parameters. Note we might decide to use #exactly the same model as our differential gene analysis for #the enrichment analysis- in this case we can extract it from #the fit
#sv <- squeezeVar(fit$sigma^2,df=fit$df.residual)

write.table(results_camera,"B236494_camera_final_enrichment.txt",sep="\t")
#You can then examine the results in “enrichment.txt”.  It is a text file.  It can be downloaded to view in a spreadsheet such as Excel.
```

## Session Information

```{r session_info, echo=TRUE}

sessionInfo()

```

# Selecting Differentially expressed genes in the dataset

```{r volcano_plot_limma_basic, echo=TRUE, fig.cap="Volcano plot of differential expression using limma"}

# Using the volcanoplot function to create the plot
volcanoplot(fit2, coef=1, style="p-value", highlight=10,
            names=rownames(fit2$coefficients), 
            xlab="Log2 Fold Change", ylab="-Log10 P-value",
            pch=20, cex=1, main="Volcano Plot")


```

```{r topTreat code }

# Extract top genes using topTreat, focusing on those exceeding the fold-change threshold
topTreat_myresults <- topTreat(fit2, coef=1, adjust="BH", sort.by="p", number=Inf)
write.table(topTreat_myresults, "B236494_topTreat_results.txt", sep="\t", quote=FALSE)


```

```{}
```

# Supplementary Material

### References:

1.  Marquardt, R.M., Kim, T.H., Yoo, J.-Y., Teasley, H.E., Fazleabas, A.T., Young, S.L., Lessey, B.A., Arora, R., and Jeong, J.-W. (2021). Endometrial epithelial ARID1A is critical for uterine gland function in early pregnancy establishment. The FASEB Journal *35*, e21209. [10.1096/fj.202002178R](https://doi.org/10.1096/fj.202002178R).

2.  

### 

## Supplementary code to load .CEL files:

```{r Supplementary Code, eval=FALSE}
# This code can be used to generate the targets file. Kindly alter the name of the GEO query to retrieve the right .tar file for analysis 

library(GEOquery)


filePaths = getGEOSuppFiles("GSE137166")

filePaths

rownames(filePaths[1])
dir()


dir(path = "./GSE137166")
setwd("./GSE137166")

system("tar -xvf GSE137166_RAW.tar")
system("gzip -d *.gz")

setwd("..")


gds <- getGEO('GSE137166', destdir=".")

gds <-gds[[1]]
  
gds

phenoData(gds)

phenoData(gds)$title


rownames(phenoData(gds))


targets_tab <-as.matrix(pData(phenoData(gds))[,c("title")])


rownames(targets_tab) <-rownames(pData(phenoData(gds)))

targets_tab

write.table(targets_tab, file="targets_tab_main.txt",sep="\t",col.names=T,row.names=T)

```

```{r generate script & pdf, eval=FALSE}
# This will give us the R script & report
# This chunk does not run by default
#purl("B236494_Basic_Analysis_Rmd_document.Rmd", output = "B236494_Basic_Analysis_Rmd_document.R", documentation = 2)

# This code chunk will give us the pdf document
#rmarkdown::render("B236494_Basic_Analysis_Rmd_document.Rmd", output_format = "pdf_document")
```
