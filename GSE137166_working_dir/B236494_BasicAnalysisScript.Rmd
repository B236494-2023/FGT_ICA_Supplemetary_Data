---
output:
  pdf_document: default
  html_document: default
---

    title: "Affymetrix Microarray Minimal pipeline"
    author: "B236494 20/04/2024"
    output: html_document

```{r setup + libload, include=FALSE}
# This is the setup code chunk that is 
# only executed once to load the necessary libraries

knitr::opts_chunk$set(echo = TRUE)

library(limma)
library(affy)
library(annotate)
library(mouse4302.db)# load chip-specific annotation
library(ggplot2)
library(knitr)
library(tinytex)

# install.packages("scatterplot3d",repo="http://cran.ma.imperia#l.ac.uk")
# Then load the library
library(scatterplot3d)
```

# B236494 - Affymetrix Microarray Analysis Basic Workflow

This code has been adapted from the BasicAnalysisScript.Rmd file provided by Simon Tomlinson. This code has been altered to account for author specific input files and samples while retaining the main features of the pipeline. The R Script can be generated for this document by running the last chunk which has been turned off by default Interpretations of the results have been provided alongside the results for convenient viewing. Comments have been added to aid in understanding the flow of execution Please ensure that the right .CEL are located in the working directory for the Code to work. This can be downloaded from the GEO website using the supplementary code provided at the end of the report.

Note: An additional analysis tool was identified known as GEO2R, the analysis of an entry in GEO can also be done using this. It is available at [https://www.ncbi.nlm.nih.gov/geo/geo2r/](https://www.ncbi.nlm.nih.gov/geo/geo2r/?acc=GSE137166)

# Pipeline Steps:

## Loading Data & Introduction

Using the read.AnnotatedDataFrame() the targets are loaded from "B236494_edited_final_targets_file.txt" file into an object. The parameters ensure that the header is accounted for. Following this, the ReadAffy() is used to load information from the .CEL files that were previously extracted from the .tar file that was obtained from Gene Expression Omnibus (GEO).

The samples are from the study, "Endometrial epithelial ARID1A is critical for uterine gland function in early pregnancy establishment" by Marquardt *et al.,* with GEO accession number GSE137166. It was an expression profiling by array experiment type.

AT-rich interaction domain 1A (ARID1A) is a large protein switch/sucrose non-fermentable (SWI/SNF) chromatin remodeling complex subunit which acts as a tumor suppressor.

The *Arid1a* gene was known to have a vital function in regulating the development of the endometrial gland which is essential for fertility after maturity and normal uterine function. Marquardt *et al.* presented evidence of how ARID1A binds and the proceeds to modulate transcription of the *Foxa2* gene that is essential for endometrial gland functioning. They also showed that deletion of *Arid1a* in a uterine specific context results in a severe defect to gland development and consequentially diminished *Foxa2* and *Lif* expression.

There were two types of mice that were used to study this gene. Arid1a d/d and Arid1a f/f mice. In Arid1a f/f the *Arid1a* has been retained while it has been deleted in the Arid1a d/d mice. At 2 weeks of growth, uteri of 3 of each type of mice was selected for RNA extraction and hybridization of Affymetrix microarrays.

The sample names are as follows:

-   GSM4072331 Arid1a f/f 1
-   GSM4072332 Arid1a f/f 2
-   GSM4072333 Arid1a f/f 3
-   GSM4072334 Arid1a d/d 1
-   GSM4072335 Arid1a d/d 2
-   GSM4072336 Arid1a d/d 3

The goals of this analysis pipeline involves a few key steps:

-   To assess the quality of the data
-   Perform Normalisation of the data
-   Robust Multi-array Average (RMA)
-   Functional Enrichment Analysis
-   Selection of Differentially Expressed Genes

The Affy and Limma Bioconductor packages will be main tools that will be used throughout this pipeline with descriptions of the code as the execution proceeds.

```{r dataload, echo=TRUE, warning=FALSE}

# Load the target file into an AnnotatedDataFrame object
adf<-read.AnnotatedDataFrame("B236494_edited_final_targets_file.txt",
                             header=TRUE,row.names=1,as.is=TRUE)

# Quickly loads all CEL files in the R working directory, 
# Refer Supplementary Material if this doesn't work
mydata <- ReadAffy()

# Viewing a summary of the AffyBatch object that has 
# all the .CEL files information loaded into it
print(mydata)

```

## Build Quality Control Plots

Now that the data has been loaded into the object, the quality of the Microarray data needs to assessed. This is important to ensure that the data has been successfully generated and that there is no severe contamination during the RNA extraction steps from the samples. Quality control can be performed by the use of box plots and a log density plot. Looking at the results of a box plot can give us an idea of the variation in data between the different replicates from each type of sample. If the difference between the replicates is large, this could imply that the extraction procedure was not done in a robust manner. The density histogram also serves the same function. Looking at these plots we can gain a preliminary idea of the quality of the data.

```{r density_plot, echo=TRUE}
png("figures/density_plot.png", width=1000, height=1000)

# Quality control plots 1
hist(mydata)

dev.off()

```

As visible from the output the density plot, the peak of expression seem to be consistent across different sample prior to normalisation which is is a sign of good quality, although some variation is distinguishable and expected. This can be observed further in the boxplot below. 

```{r boxplot raw, echo=TRUE}

# Quality control plots 2

png("figures/boxplot_non_normalised_2.png", width=1000, height=1000)

# Specifying colours for each group
colours <- c(rep("yellow",3),rep("red",3))

# Reduce font size for axis labels to increase readability
par(cex.axis=0.9)

boxplot(mydata, col=colours, las=1)

dev.off()

```

The boxplots results is promising as well. The different measures of the boxplot provide a good overview of what the data is like for each sample and between the two groups, Arid1a f/f mice in yellow and Arid1a mice in red. The median line of all the samples seems to be quite similar which indicates that the overall expression values seem to consistent across the different samples as seen in the density plot. There is some variation within each group, as seen by the interquartile range (height of boxplots), between replicates but not to a very high level. Thus the replicates possess a good amount of similarity to each other. The lack of high variance between the two groups is representative of similar levels of expression between the two conditions. 


## Normalise the data using RMA

Now t

```{r normalise, echo=FALSE}

eset <- rma(mydata)
eset
# To obtain a matrix of the expression values, use exprs() 
values <- exprs(eset)

```

## Plot Normalised Data

```{r plot_normalised boxplot, echo=TRUE }

# Boxplot to observe the results of normalisation
png("figures/boxplot_normalised_2.png", width=1000, height=1000)

# Increase font size for axis labels to increase readability
par(cex.axis=1.4)

boxplot(values, col=colours,las=1)

dev.off()
```

```{r plot_normalised mva without normalisation}

# The mva plot for the non-normalised raw data

png("figures/mva_without_normalisation.png", width=1000, height=1000)

par(cex.axis=0.3, cex.lab=0.5, cex=0.5)
mva.pairs(pm(mydata))

dev.off()
```

```{r plot_normalised mva with normalisation}

# MA plot of all the samples which have been normalised

png("figures/mva_with_normalisation.png", width=1000, height=1000)

par(cex.axis=0.7, cex.lab=0.5, cex=0.5)
mva.pairs(values)

dev.off()
```

## Plot Cluster Dendogram

```{r heatmap_normalised, echo=TRUE}

png("figures/Cluster_Dendogram.png", width=500, height=500)

# To facilitate interpretation, let’s replace the columns # # header,currently
# displaying the filename, to show the name of each sample 
# (if you have a targets file)
colnames(values) <- rownames(pData(adf))
# Performs hierarchical clustering with average linkage based on
# Pearson’s Correlation Coefficient
hc<-hclust(as.dist(1-cor(values, method="pearson")), method="average")
plot(hc)

dev.off()
```

## Perform PCA

```{r pca_normalised, echo=TRUE}

png("figures/PCA.png", width=850, height=600)

### removed scale=T, i think its already normalised
pca <- prcomp(t(values))
# Plot the PCA results

s3d<-scatterplot3d(pca$x[,1:3], pch=19, color=rainbow(1))
s3d.coords <- s3d$xyz.convert(pca$x[,1:3])
text(s3d.coords$x, s3d.coords$y, labels = colnames(values),pos = 3,offset = 0.5)

dev.off()
```

## Perform fold filtering

```{r fold_filtering, include=FALSE}

#obtaining a matrix of expression values
exprsvals <- exprs(eset)
#RMA outputs log2 data while MAS5 outputs linear data
#To convert from log…
exprsvals10 <-2^exprsvals
#check conversion
exprsvals[1:10,]
#converted
exprsvals10[1:10,]

#More fold filtering
#check order of sample names
mysamples <- sampleNames(eset)
#display the list
mysamples
#it is useful to obtain a vector of ProbeIDs here
probesets <- probeNames(mydata)
#display the first 10 ProbeSets
probesets[1:10]

#Build final fold table
#Calculate the means
#Note mean of the log is not the same as the log of the mean!!
Arid1a_f_f.mean <- apply(exprsvals10[,c("GSM4072331_AF1.CEL", "GSM4072332_AF2.CEL","GSM4072333_AF3.CEL")],1,mean)

Arid1a_d_d.mean <- apply(exprsvals10[,c("GSM4072334_AD1.CEL", "GSM4072335_AD2.CEL","GSM4072336_AD3.CEL")],1,mean)
#calculate some fold changes
Arid1a_fold_change <- Arid1a_f_f.mean/Arid1a_d_d.mean
##ES_iPS_OK <-ES.mean /iPS_OK.mean
##ES_iPS_4F <-ES.mean /iPS_4F.mean
##ES_NSC <-ES.mean /NSC.mean

#build a summary table to hold all the data

##all.data= cbind(ES.mean,iPS_OK.mean,iPS_4F.mean, NSC.mean, ES_iPS_OK,ES_iPS_4F, ES_NSC)
all.data= cbind(Arid1a_fold_change)
#check the column names
colnames(all.data)
#write the table of means as an output
write.table(all.data,file="B236494_group_means.txt", quote=F,
sep="\t",col.names=NA)
```

## Beginning statistical analysis

```{r limma_stats, echo=TRUE}

#Check original sample order
sampleNames(eset)
#Rename the samples
sampleNames(eset) <-
c("GSM4072331_AF1.CEL","GSM4072332_AF2.CEL","GSM4072333_AF3.CEL","GSM4072334_AD1.CEL","GSM4072335_AD2.CEL","GSM4072336_AD3.CEL")
#Check the samples have renamed
sampleNames(eset)

```

```{r building_annotation, echo=TRUE}
##Building annotation for differential gene identification
#establish annotation for MOE430v2
#which annotation do we need
#modified from 
#http://gettinggeneticsdone.blogspot.co.uk/2012/01/
#annotating-limma-#results-with-gene.html

eset@annotation


#packages in the annotation package
ls("package:mouse4302.db")

#build an annotation table
ID <- featureNames(eset)
Symbol <- getSYMBOL(ID, "mouse4302.db")
Name <- as.character(lookUp(ID, "mouse4302.db", "GENENAME"))
tmp <- data.frame(ID=ID, Symbol=Symbol, Name=Name, stringsAsFactors=F)
tmp[tmp=="NA"] <- NA #fix padding with NA characters 
#assign as feature data of the current Eset
fData(eset) <- tmp

# Check for rows that don’t have an EntrezID
missing_entrezid_count <- sum(is.na(fData(eset)$ENTREZID))

print(missing_entrezid_count)

```

## Statistical analysis using Limma

```{r limma_statistical_analysis, echo=TRUE}

#Build the design matrix
design <- model.matrix(~-1+factor(c(1,1,1,2,2,2)))
colnames(design) <- c("Arid1a_f_f","Arid1a_d_d")
#Check it makes sense
sampleNames(eset)
#output the design matrix
design

#This instructs Limma which comparisons to make
contrastmatrix <- makeContrasts(Arid1a_f_f-Arid1a_d_d,levels=design)
contrastmatrix

#issue these commands to fit the model
#and make the contrasts
fit <- lmFit(eset, design)

fit2 <- contrasts.fit(fit, contrastmatrix)

#this last part essentially moderates the t-statistic using 
#the borrowed variance approach described in class
fit2 <- eBayes(fit2)

#get the results
topTable(fit2,coef=1,adjust="fdr")
myresults <-topTable(fit2,coef=1, adjust="fdr", number=nrow(eset))
write.table(myresults,"B236494_myresults.txt")
```

## Carry out Functional Enrichment analysis

```{r functional_enrichment, echo=TRUE}

Mm.H <- readRDS("/shared_files/MSigDB/Mm.h.all.v7.1.entrez.rds") 

#Check that you have the required objects
ls()

#Show the full contents of the annotation package
ls("package:mouse4302.db")

#Show the annotation keys in this database
keytypes(mouse4302.db) 

sampleNames(eset)
```

## Process annotation for functional enrichment

```{r process_annotation_for_enrichment, echo=TRUE}

#Here we select from the annotation a number of keys with the primary key being PROBEID
res <- select(mouse4302.db, keys = rownames(eset), columns = c("ENTREZID", "ENSEMBL","SYMBOL"), keytype="PROBEID")
#View the top of the table
head(res)
#find the index of each row of the expression set in the 
#annotation object res
idx <- match(rownames(eset), res$PROBEID)
#Use the index to set the phenotypic data in the ExpressionSet
fData(eset) <- res[idx, ]
head(fData(eset), 10)
#Find all rows that don’t have an EntrezID and remove then
eset_t<-eset[is.na(fData(eset)$ENTREZID)==0,]
```

## Functional Enrichment Analysis

```{r convert_indicex, echo=TRUE}

#convert to indexes
H.indices <- ids2indices(Mm.H,fData(eset_t)$ENTREZID)
#Pick the most suitable enrichment analysis tool to find 
#enrichment signatures in the data and run this tool So:-

#I just run mroast here as an example- justify the selection of this method!

#if you want to run mroast
#results_mroast <-mroast(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#if you want to run camera
results_camera <-camera(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#if you want to run romer
#results_romer <-romer(eset_t,index=H.indices,design=design,contrast=contrastmatrix[,1],adjust.method = "BH")
#View the results
results_camera

#Use help for other parameters. Note we might decide to use 
#exactly the same model as our differential gene analysis for 
#the enrichment analysis- in this case we can extract it from #the fit
#sv <- squeezeVar(fit$sigma^2,df=fit$df.residual)

write.table(results_camera,"B236494_camera_final_enrichment.txt",sep="\t")
#You can then examine the results in “enrichment.txt”.  It is a text file.  It can be downloaded to view in a spreadsheet such as Excel.
```

## Session Information

```{r session_info, echo=TRUE}

sessionInfo()

```

# Selecting Differentially expressed genes in the dataset

```{r volcano_plot_limma_basic, echo=TRUE, fig.cap="Volcano plot of differential expression using limma"}

png("figures/volcano_plot_limma.png", width=1500, height=750)

# Using the volcanoplot function to create the plot
volcanoplot(fit2, coef=1, style="p-value", highlight=10,
            names=rownames(fit2$coefficients), 
            xlab="Log2 Fold Change", ylab="-Log10 P-value",
            pch=20, cex=1, main="Volcano Plot")

dev.off()

```

```{r topTreat code }

# Extract top genes using topTreat, focusing on those exceeding the fold-change threshold
topTreat_myresults <- topTreat(fit2, coef=1, adjust="BH", sort.by="p", number=Inf)
write.table(topTreat_myresults, "B236494_topTreat_results.txt", sep="\t", quote=FALSE)


```

# Supplementary Material

### References:

1.  Marquardt, R.M., Kim, T.H., Yoo, J.-Y., Teasley, H.E., Fazleabas, A.T., Young, S.L., Lessey, B.A., Arora, R., and Jeong, J.-W. (2021). Endometrial epithelial ARID1A is critical for uterine gland function in early pregnancy establishment. The FASEB Journal *35*, e21209. [10.1096/fj.202002178R](https://doi.org/10.1096/fj.202002178R).

2.  

### 

## Supplementary code to load .CEL files:

```{r Supplementary Code, eval=FALSE}
# This code can be used to generate the targets file. 
# Kindly alter the name of the GEO query to retrieve
# the right .tar file for analysis 

library(GEOquery)


filePaths = getGEOSuppFiles("GSE137166")

filePaths

rownames(filePaths[1])
dir()


dir(path = "./GSE137166")
setwd("./GSE137166")

system("tar -xvf GSE137166_RAW.tar")
system("gzip -d *.gz")

setwd("..")


gds <- getGEO('GSE137166', destdir=".")

gds <-gds[[1]]
  
gds

phenoData(gds)

phenoData(gds)$title


rownames(phenoData(gds))


targets_tab <-as.matrix(pData(phenoData(gds))[,c("title")])


rownames(targets_tab) <-rownames(pData(phenoData(gds)))

targets_tab

write.table(targets_tab, file="targets_tab_main.txt",sep="\t",col.names=T,row.names=T)

```

```{r generate script & pdf, eval=FALSE}
# This will give us the R script & report
# This chunk does not run by default
#purl("B236494_Basic_Analysis_Rmd_document.Rmd", output = "B236494_Basic_Analysis_Rmd_document.R", documentation = 2)

# This code chunk will give us the pdf document
#rmarkdown::render("B236494_Basic_Analysis_Rmd_document.Rmd", output_format = "pdf_document")
```
